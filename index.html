<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Ryan Yates" />
  <meta name="date" content="1-2-2013" />
  <title>GHC STM Notes</title>
  <link rel="stylesheet" href="style.css" type="text/css" />
</head>
<body>
<h1 class="title">GHC STM Notes</h1>
<h1 id="introduction">Introduction</h1>
<p>This document give an overview of the runtime system (RTS) support for GHC's STM implementation. Specifically we look at the case where fine grain locking is used (<code>STM_FG_LOCKS</code>).</p>
<h1 id="background">Background</h1>
<p>TODO: fill in enough background details and links, a good starting point is here: <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode"><code class="url">http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode</code></a></p>
<h2 id="definitions">Definitions</h2>
<dl>
<dt><code>Capability</code></dt>
<dd><p>Corresponds to a CPU. The number of capabilities should match the number of CPUs. See <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#Capabilities">cap</a>.</p>
</dd>
<dt><code>TSO</code></dt>
<dd><p>Thread State Object. The state of a Haskell thread. See <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#ThreadStateObjects">tso</a>.</p>
</dd>
<dt>Heap object</dt>
<dd><p>Objects on the heap all take the form of an <code>StgClosure</code> structure with a header pointing and a payload of data. The header points to code and an info table. See <a href="http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects">heap</a>.</p>
</dd>
</dl>
<h1 id="overview">Overview</h1>
<p>TODO: code examples in all of the subsections of the overview.</p>
<p>At the high level, transactions are computations that read and write to <code>TVar</code>s with changes only being committed atomically and reads only seeing consistent state. Transactions can also be composed together, building new transactions out of existing transactions. In the RTS each transaction keeps a record of its interaction with the <code>TVar</code>s it touches in a <code>TRec</code>. A pointer to this record is stored in the TSO that is running the transaction.</p>
<h2 id="nesting">Nesting</h2>
<p>In addition, transactions can be &quot;retried&quot; with explicit <code>retry</code> that aborts the transaction and allows an alternative transaction to run on the current thread with the <code>orElse</code> combinator or the same transaction can be run again when changes happen on another thread.</p>
<h2 id="validation">Validation</h2>
<p>Before a transaction can publish its effects it must check that it has seen a consistent view of memory while it was executing.</p>
<h2 id="committing">Committing</h2>
<p>When we try to commit we check that invariants continue to hold, that we have seen a consistent view of memory (validation), and that version numbers have stayed consistent. If all this holds we will have acquired the locks for the affected <code>TVar</code>s and can atomically make visible changes to memory (with respect to other transactions).</p>
<p>TODO: talk about the mechanism, locking, and have worked examples.</p>
<h2 id="aborting">Aborting</h2>
<p>Aborting is simply throwing away changes that are stored in the <code>TRec</code>.</p>
<h2 id="invariants">Invariants</h2>
<p>As a transaction is executing it can collect a queue of dynamically checked invariants. These invariants are transactions that are never committed, but if they raise an exception when executed successfully that exception will propagate out of the atomic frame.</p>
<dl>
<dt><code>check#</code></dt>
<dd><p>Primitive operation that adds an invariant (transaction to run) to the queue of the current <code>TRec</code> by calling <code>stmAddInvariantToCheck</code>.</p>
</dd>
<dt><code>checkInv :: STM a -&gt; STM ()</code></dt>
<dd><p>A wrapper for <code>check#</code> (to give it the <code>STM</code> type).</p>
</dd>
<dt><code>alwaysSucceeds :: STM a -&gt; STM ()</code></dt>
<dd><p>This is the <code>check</code> from the &quot;Transactional memory with data invariants&quot; paper.<br />The action immediately runs, wrapped in a nested transaction so that it will never commit but will have an opportunity to raise an exception. If successful, the originally passed action is added to the invariant queue.</p>
</dd>
<dt><code>always :: STM Bool -&gt; STM ()</code></dt>
<dd><p>Takes an <code>STM</code> action that results in a <code>Bool</code> and adds an invariant that throws an exception when the result of the transaction is <code>False</code>.</p>
</dd>
</dl>
<p>The bookkeeping for invariants is in each <code>TRec</code>s <code>invariants_to_check</code> queue and the <code>StgAtomicallyFrame</code>s <code>next_invariant_to_check</code> field. Each invariant is in a <code>StgAtomicInvariant</code> structure that includes the <code>STM</code> action, the <code>TRec</code> where it was last executed, and a lock (TODO: why a lock?). This is added to the current <code>TRec</code>s queue when <code>check#</code> is executed.</p>
<p>When a transaction completes, execution will reach the <code>stg_atomically_frame</code> and the <code>TRec</code>s <code>enclosing_trec</code> will be <code>NO_TREC</code> (a nested transaction would have a <code>stg_catch_retry_frame</code> before the <code>stg_atomically_frame</code> to handle cases of non-empty <code>enclosing_trec</code>). The frame will then check the invariants by collecting the invariants it needs to check with <code>stmGetInvariantsToCheck</code>, dequeuing each, executing, and when (or if) we get back to the frame aborting the invariant action (if it failed, we would not get here due to an exception, if it succeeds we do not want its effects). Once all the invariants have been checked, the frame will be attempt to commit.</p>
<p>TODO: Explain how <code>stmGetInvariantsToCheck</code> works.</p>
<p>For each update entry (a write to a <code>TVar</code>) in the <code>TRec</code></p>
<p>Note that there is a <code>check</code> in the <code>stm</code> package in <code>Control.Monad.STM</code> which matches the <code>check</code> from the &quot;Beautiful concurrency&quot; chapter of &quot;Beautiful code&quot; <a href="http://research.microsoft.com/pubs/74063/beautiful.pdf">beauty</a>:</p>
<pre><code>check :: Bool -&gt; STM ()
check b = if b then return () else retry
</code></pre>
<p>It requires no additional runtime support. If it is a transaction that produces the <code>Bool</code> argument it will be committed (when <code>True</code>) and it is only a one time check, not an invariant that will be checked at commits.</p>
<h2 id="watch-queues">Watch Queues</h2>
<p>With <code>retry</code>, <code>orElse</code>, and invariants we have conditions beyond a consistent view of memory that need to hold for the transaction to commit. To efficiently resolve failing conditions, transactions are not immediately restarted but wait for something to change that might make it possible to succeed on a subsequent attempt. This is done using the watch queue associated with each <code>TVar</code>. The watch queue contains invariants (when ???) and TSOs. When a transaction executes <code>retry</code> and there is no <code>CATCH_RETRY_FRAME</code> (from an <code>orElse</code>) above it (it has exhausted all the alternatives) the transaction will wait by calling <code>stmWait</code>. This verifies that the transaction is valid (acquiring locks for all <code>TVar</code>s in the <code>TRec</code>) and if valid adds the transaction's TSO to each <code>TVar</code>s watch queue. When another thread commits a transaction that writes to a <code>TVar</code>, each TSO on the watch queue is woken (scheduled for running on the current capability).</p>
<p>TODO: add details about watch queues.</p>
<h2 id="fine-grain-locking">Fine Grain Locking</h2>
<p>The locks in fine grain locking (<code>STM_FG_LOCKS</code>) are at the <code>TVar</code> level and are implemented by placing the locking thread's <code>TRec</code> in the <code>TVar</code>s current value using a compare and swap (<code>lock_tvar</code>). The value observed when locking is returned by <code>lock_tvar</code>. To test if a <code>TVar</code> is locked the value is inspected to see if it is a <code>TRec</code> (checking that the closure's info table pointer is to <code>stg_TREC_HEADER_info</code>). If a <code>TRec</code> is found <code>lock_tvar</code> will spin reading the <code>TVar</code>s current value until it is not a <code>TRec</code> and then attempt again to obtain the lock. Unlocking is simply a write of the current value of the <code>TVar</code>. There is also a conditional lock <code>cond_lock_tvar</code> which will obtain the lock if the <code>TVar</code>s current value is the given expected value. If the <code>TVar</code> is already locked this will not be the case (the value would be a <code>TRec</code>) and if the <code>TVar</code> has been updated to a new (different) value then locking will fail because the value does not match the expected value. A compare and swap is used for <code>cond_lock_tvar</code>.</p>
<h1 id="code-reference">Code Reference</h1>
<p>TODO: flesh out these notes.</p>
<h2 id="structures">Structures</h2>
<p>The structures used for STM are found in <code>includes/rts/storage/Closures.h</code>.</p>
<dl>
<dt><code>StgTVarWatchQueue</code></dt>
<dd><p>Doubly-linked queue of <code>StgClosure</code> (either <code>StgTSO</code> or <code>StgAtomicInvariant</code>).</p>
</dd>
<dt><code>StgTVar</code></dt>
<dd><p>Current value (<code>StgClosure</code>), a watch queue, and number of updates.</p>
</dd>
<dt><code>StgAtomicInvariant</code></dt>
<dd><p>Code (<code>StgClosure</code>), last execution (<code>StgTRecHeader</code>), lock (<code>StgWord</code>).</p>
</dd>
<dt><code>TRecEntry</code></dt>
<dd><p>Pointer to a <code>StgTVar</code>, expected value (<code>StgClosure</code>), new value (<code>StgClosure</code>), and number of updates.</p>
</dd>
<dt><code>StgTRecChunk</code></dt>
<dd><p>Singly-linked list of chunks, next entry index, and an array of <code>TRecEntry</code>s (size <code>TREC_CHUNK_NUM_ENTRIES = 16</code>)</p>
</dd>
<dt><code>TRecState</code></dt>
<dd><p>Enumeration: active, condemned, committed, aborted, or waiting.</p>
</dd>
<dt><code>StgInvariantCheckQueue</code></dt>
<dd><p>Singly-linked list of invariants (<code>StgAtomicInvariant</code>), and owned executions (<code>StgTRecHeader</code>).</p>
</dd>
<dt><code>StgTRecHeader_</code></dt>
<dd><p>Enclosing transactional record (<code>StgTRecHeader_</code>, nesting?), current chunk (<code>StgTRecChunk</code>), invariants to check (<code>StgInvariantCheckQueue</code>), and state. When <code>t-&gt;enclosing_trec</code> is <code>NO_TREC</code> then <code>t</code> is a top-level transaction. Otherwise 't' is a nested transaction and has a parent.</p>
</dd>
<dt><code>StgAtomicallyFrame</code></dt>
<dd><p>Code, next invariant to check (<code>StgTVarWatchQueue</code>), and result (<code>StgClosure</code>).</p>
</dd>
<dt><code>StgCatchSTMFrame</code></dt>
<dd><p>Code and handler.</p>
</dd>
<dt><code>StgCatchRetryFrame</code></dt>
<dd><p>First code, alternate code, and flag that is true if running alternate code.</p>
</dd>
</dl>
<h2 id="c-functions">C functions</h2>
<p><code>rts/STM.c</code></p>
<p>And now STM functions.</p>
<dl>
<dt><code>lock_stm</code> and <code>unlock_stm</code></dt>
<dd><p>These do nothing as they represent the coarse grain lock code path.</p>
</dd>
<dt><code>lock_tvar</code> and <code>unlock_tvar</code></dt>
<dd><p>When a <code>TVar</code> is locked its current value is replaced with the owning <code>TRec</code>. Acquiring the lock is done by first checking that the value is not a <code>TRec</code>, then using compare and swap with that value and the <code>TRec</code> that wants to acquire the lock. If the value has change before the <code>cas</code> try again. Unlocking simply puts a non-<code>TRec</code> value in the <code>TVar</code>.</p>
</dd>
<dt><code>revert_ownership</code></dt>
<dd><p>Releases locks on <code>TVar</code>s, restoring their expected values (which were stashed in the lock holding <code>TRec</code>).</p>
</dd>
<dt><code>validate_and_acquire_ownership</code></dt>
<dd><p>Takes an active, waiting or condemned <code>TRec</code> and checks that each <code>TVar</code> in the record holds the <code>TRec</code>'s expected value. When called during commit, update <code>TVar</code>s (those written to) are locked. When called from wait, all <code>TVar</code>s are locked. The locks are released if a discrepancy is found. As the read only <code>TVar</code>s are encountered (those where the record's expected value matches the &quot;new&quot; value) the <code>TVar</code>s number of updates is written to the <code>TRec</code>.</p>
<p>In the end, if <code>validate_and_acquire_ownership</code> returns true, then the record is consistent, the number of updates on any read only is recorded, and locks are held for every write <code>TVar</code>. If any inconsistency is seen (a <code>TVar</code>'s current value doesn't match the <code>TRec</code>'s expected value) or a lock is held (same check as locks overwrite current value) false will be returned.</p>
</dd>
<dt><code>check_read_only</code></dt>
<dd><p>Checks that the read only entries in the <code>TRec</code> have the same number of updates as the <code>TVar</code>s themselves.</p>
</dd>
<dt><code>getToken</code></dt>
<dd><p>Version numbers are checked for overflow by keeping a global count of transactions (<code>max_commits</code>) and checking it for overflow in commit. The global count is incremented in batches when a per capability commit count reaches zero (from 1024).</p>
</dd>
<dt><code>stmStartTransaction</code></dt>
<dd><p>Consumes a global version number with <code>getToken</code> and allocates a new <code>TRec</code>.</p>
</dd>
</dl>
<p>TODO: Finish reference.</p>
<h2 id="cmm-code">Cmm Code</h2>
<p>The higher level Haskell code calls several primitive operations written in GHC Cmm. The code for</p>
<p><code>rts/primops.cmm</code></p>
<p>TODO: primop details.</p>
<h2 id="supporting-code">Supporting Code</h2>
<p>TODO: schedule, GC, and exception details.</p>
<p><code>rts/Schedule.c</code></p>
<p><code>rts/RaiseAsync.c</code></p>
</body>
</html>
